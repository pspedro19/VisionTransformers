#!/usr/bin/env python3
"""
Demo del Sistema de Doble Canal de √öltima Generaci√≥n
====================================================

Este script demuestra el sistema completo de doble canal con:
- Detecci√≥n autom√°tica de hardware
- Procesamiento optimizado
- Monitoreo en tiempo real
- Visualizaci√≥n de resultados
"""

import os
import sys
import time
import logging
from pathlib import Path
from typing import Optional

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('dual_channel_demo.log')
    ]
)

logger = logging.getLogger(__name__)

def print_banner():
    """Imprime el banner del sistema."""
    banner = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    SISTEMA DE DOBLE CANAL DE √öLTIMA GENERACI√ìN              ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  üéØ Canal A: Atenci√≥n Espaciotemporal Global (GMAR)                        ‚ïë
‚ïë  üéØ Canal B: Atenci√≥n por Objetos (Object Tracking)                        ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  ‚ö° Optimizaciones: Flash Attention 2.0, TensorRT, Mixed Precision         ‚ïë
‚ïë  üîß Detecci√≥n autom√°tica de hardware y configuraci√≥n inteligente           ‚ïë
‚ïë  üìä Monitoreo en tiempo real con optimizaciones din√°micas                  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
    print(banner)

def print_hardware_requirements():
    """Imprime los requisitos de hardware."""
    requirements = """
üìã REQUISITOS DE HARDWARE:

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GPU Recomendadas:                                                          ‚îÇ
‚îÇ ‚Ä¢ RTX 4090 (24GB) - Ultra Quality, 4K, 20-25 FPS                          ‚îÇ
‚îÇ ‚Ä¢ RTX 4080 (16GB) - High Quality, 1440p, 15-20 FPS                        ‚îÇ
‚îÇ ‚Ä¢ RTX 4070 Ti (12GB) - High Quality, 1080p, 12-15 FPS                     ‚îÇ
‚îÇ ‚Ä¢ RTX 3080 (10GB) - Balanced, 1080p, 10-12 FPS                            ‚îÇ
‚îÇ ‚Ä¢ RTX 3070 (8GB) - Balanced, 720p, 8-10 FPS                               ‚îÇ
‚îÇ ‚Ä¢ RTX 3060 (6GB) - Optimized, 720p, 6-8 FPS                               ‚îÇ
‚îÇ ‚Ä¢ RTX 3050 (4GB) - Memory Saver, 480p‚Üí720p, 4-6 FPS                       ‚îÇ
‚îÇ ‚Ä¢ GTX 1660 (6GB) - Legacy, 480p, 3-5 FPS                                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ RAM M√≠nima: 8GB (Recomendado: 16GB+)                                      ‚îÇ
‚îÇ CPU: 4+ cores (Recomendado: 8+ cores)                                     ‚îÇ
‚îÇ Espacio: 5GB+ libre para archivos temporales                              ‚îÇ
‚îÇ CUDA: 11.8+ (para GPUs NVIDIA)                                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""
    print(requirements)

def get_video_input() -> Optional[str]:
    """Obtiene la ruta del video de entrada del usuario."""
    print("\nüé¨ SELECCI√ìN DE VIDEO:")
    print("=" * 50)
    
    # Verificar si hay videos en el directorio data/uploads
    uploads_dir = Path("data/uploads")
    if uploads_dir.exists():
        video_files = list(uploads_dir.glob("*.mp4")) + list(uploads_dir.glob("*.avi")) + list(uploads_dir.glob("*.mov"))
        
        if video_files:
            print("üìÅ Videos encontrados en data/uploads:")
            for i, video_file in enumerate(video_files, 1):
                size_mb = video_file.stat().st_size / (1024 * 1024)
                print(f"  {i}. {video_file.name} ({size_mb:.1f} MB)")
            
            print(f"  {len(video_files) + 1}. Especificar ruta manual")
            
            while True:
                try:
                    choice = input(f"\nSelecciona un video (1-{len(video_files) + 1}): ").strip()
                    choice_num = int(choice)
                    
                    if 1 <= choice_num <= len(video_files):
                        return str(video_files[choice_num - 1])
                    elif choice_num == len(video_files) + 1:
                        break
                    else:
                        print("‚ùå Opci√≥n inv√°lida")
                except ValueError:
                    print("‚ùå Por favor ingresa un n√∫mero v√°lido")
    
    # Solicitar ruta manual
    while True:
        video_path = input("\nüìÇ Ingresa la ruta completa del video: ").strip()
        
        if not video_path:
            print("‚ùå La ruta no puede estar vac√≠a")
            continue
        
        video_file = Path(video_path)
        if not video_file.exists():
            print(f"‚ùå El archivo no existe: {video_path}")
            continue
        
        if video_file.suffix.lower() not in ['.mp4', '.avi', '.mov', '.mkv']:
            print("‚ùå Formato de video no soportado. Usa: .mp4, .avi, .mov, .mkv")
            continue
        
        return str(video_file)

def select_quality_mode() -> str:
    """Permite al usuario seleccionar el modo de calidad."""
    print("\nüéõÔ∏è  MODO DE CALIDAD:")
    print("=" * 50)
    
    modes = {
        "1": {
            "name": "R√ÅPIDO",
            "description": "Procesamiento r√°pido con calidad media",
            "time": "2-3 minutos",
            "quality": "Media",
            "resolution": "480p"
        },
        "2": {
            "name": "BALANCEADO",
            "description": "Balance entre velocidad y calidad (Recomendado)",
            "time": "4-5 minutos",
            "quality": "Buena",
            "resolution": "720p upscaled"
        },
        "3": {
            "name": "CALIDAD",
            "description": "M√°xima calidad posible",
            "time": "8-10 minutos",
            "quality": "M√°xima",
            "resolution": "720p nativa"
        }
    }
    
    for key, mode in modes.items():
        print(f"  {key}. {mode['name']}")
        print(f"     ‚è±Ô∏è  Tiempo: {mode['time']}")
        print(f"     üé® Calidad: {mode['quality']}")
        print(f"     üìê Resoluci√≥n: {mode['resolution']}")
        print(f"     üìù {mode['description']}")
        print()
    
    while True:
        choice = input("Selecciona el modo (1-3): ").strip()
        if choice in modes:
            selected_mode = modes[choice]
            print(f"\n‚úÖ Modo seleccionado: {selected_mode['name']}")
            print(f"   Tiempo estimado: {selected_mode['time']}")
            return choice
        else:
            print("‚ùå Opci√≥n inv√°lida. Selecciona 1, 2 o 3.")

def progress_callback(progress: float):
    """Callback para mostrar el progreso."""
    bar_length = 40
    filled_length = int(bar_length * progress / 100)
    bar = '‚ñà' * filled_length + '‚ñë' * (bar_length - filled_length)
    
    print(f"\rüîÑ Progreso: {bar} {progress:.1f}%", end='', flush=True)
    
    if progress >= 100:
        print()  # Nueva l√≠nea al completar

def main():
    """Funci√≥n principal del demo."""
    print_banner()
    print_hardware_requirements()
    
    # Verificar si el usuario quiere continuar
    print("\n‚ö†Ô∏è  ADVERTENCIA:")
    print("Este sistema utiliza recursos intensivos de GPU.")
    print("Aseg√∫rate de tener una GPU compatible y drivers actualizados.")
    
    continue_choice = input("\n¬øContinuar con la demostraci√≥n? (s/N): ").strip().lower()
    if continue_choice not in ['s', 'si', 's√≠', 'y', 'yes']:
        print("üëã Demo cancelado. ¬°Hasta luego!")
        return
    
    try:
        # Importar el pipeline optimizado
        from src.core.optimized_pipeline import OptimizedDualChannelPipeline
        
        # Obtener entrada del usuario
        video_path = get_video_input()
        if not video_path:
            print("‚ùå No se seleccion√≥ ning√∫n video")
            return
        
        quality_mode = select_quality_mode()
        
        print(f"\nüöÄ INICIANDO PROCESAMIENTO:")
        print("=" * 50)
        print(f"üìπ Video: {Path(video_path).name}")
        print(f"üéõÔ∏è  Modo: {quality_mode}")
        print(f"‚è∞ Iniciando a las: {time.strftime('%H:%M:%S')}")
        
        # Inicializar pipeline
        pipeline = OptimizedDualChannelPipeline()
        
        # Inicializar sistema con detecci√≥n autom√°tica
        print("\nüîç DETECTANDO HARDWARE...")
        hardware_info, performance_profile, config = pipeline.initialize_system()
        
        # Mostrar recomendaciones
        recommendations = pipeline.get_recommendations()
        if recommendations:
            print("\nüîß RECOMENDACIONES:")
            for rec in recommendations:
                print(f"  {rec}")
        
        # Procesar video
        print(f"\nüé¨ PROCESANDO VIDEO...")
        print("Presiona Ctrl+C para detener el procesamiento")
        
        result = pipeline.process_video(
            video_path=video_path,
            progress_callback=progress_callback
        )
        
        # Mostrar resultados
        print(f"\n‚úÖ PROCESAMIENTO COMPLETADO!")
        print("=" * 50)
        print(f"üìÅ Archivo generado: {result.output_path}")
        print(f"‚è±Ô∏è  Tiempo total: {result.processing_time:.2f} segundos")
        print(f"üé¨ Frames procesados: {result.frames_processed}")
        print(f"üìä FPS promedio: {result.avg_fps:.1f}")
        
        # M√©tricas de calidad
        if result.quality_metrics:
            print(f"\nüìà M√âTRICAS DE CALIDAD:")
            print(f"  üìè Tama√±o del archivo: {result.quality_metrics.get('file_size_mb', 0):.1f} MB")
            print(f"  üé¨ N√∫mero de frames: {result.quality_metrics.get('frame_count', 0)}")
            print(f"  üìê Resoluci√≥n: {result.quality_metrics.get('resolution', 0)} p√≠xeles")
            print(f"  ‚è±Ô∏è  Duraci√≥n: {result.quality_metrics.get('duration', 0):.1f} segundos")
            print(f"  üéØ FPS del GIF: {result.quality_metrics.get('fps', 0):.1f}")
        
        # Resumen de rendimiento
        if result.performance_summary:
            print(f"\nüìä RESUMEN DE RENDIMIENTO:")
            print(f"  üî• Pico de memoria GPU: {result.performance_summary.get('peak_gpu_memory_percent', 0):.1f}%")
            print(f"  üå°Ô∏è  Temperatura m√°xima: {result.performance_summary.get('peak_temperature', 0):.1f}¬∞C")
            print(f"  ‚ö° Optimizaciones aplicadas: {result.performance_summary.get('optimizations_applied', 0)}")
            print(f"  ‚ö†Ô∏è  Alertas totales: {result.performance_summary.get('total_alerts', 0)}")
        
        print(f"\nüéâ ¬°Procesamiento completado exitosamente!")
        print(f"üìÇ El GIF est√° disponible en: {result.output_path}")
        
        # Abrir el archivo si es posible
        try:
            import subprocess
            import platform
            
            if platform.system() == "Windows":
                os.startfile(result.output_path)
            elif platform.system() == "Darwin":  # macOS
                subprocess.run(["open", result.output_path])
            else:  # Linux
                subprocess.run(["xdg-open", result.output_path])
                
            print("üîç Abriendo archivo generado...")
        except:
            print("üí° Puedes abrir manualmente el archivo generado para ver el resultado.")
        
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è  Procesamiento detenido por el usuario")
        if 'pipeline' in locals():
            pipeline.stop_processing()
    except Exception as e:
        print(f"\n‚ùå Error durante el procesamiento: {e}")
        logger.error(f"Error en demo: {e}", exc_info=True)
    
    print("\nüëã ¬°Gracias por usar el Sistema de Doble Canal!")

if __name__ == "__main__":
    main() 